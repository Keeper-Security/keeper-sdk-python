"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file

Protocol Buffers used in Keeper Automator

Keeper calls the Automator - the automator never initiates a request.

To call Automator, use the same ApiRequest format used to call Keeperapp APIs.
The only difference is that the one-time transmission key is encrypted
with the automatorEncryptionKey which is created by the Automator instance and
is unique to each Automator instance.  However, if Keeper receives a message
that it can't decrypt, it will try the standard transmission key.

Each automator instance has an id that is created by Keeperapp and assigned at initialization.

The Automator supports a small number of APIs.
It always replies with AutomatorResponse which contains one of
ApproveDeviceResponse, ApproveTeamsForUserResponse, ApproveTeamsResponse, NotInitializedResponse, StatusResponse, or ErrorResponse

If it has not been initialized the reply always contains NotInitializedResponse.


Mike Hewett   March 2021
Last updated: 22 Apr 2021  After revising architecture with Gene.
              05 May 2021  To change the name from Webhook to Automator
              18 Jun 2021  Added AutomatorRequest so clients can create and configure an Automator in Keeper
              26 Aug 2021  Added a skill to the AutomatorCreateRequest
                           Added a way for clients to send an enterprise key to the Automator
              26 Sep 2022  Added IP address to device approval request
              20 Jun 2023  Added four new messages to support team user approval
              13 Jul 2023  Added a new field to TeamDescription for team approval
              17 Jul 2023  Added treeKey to the setup protobuff
              13 Oct 2023  Added new messages to support team approval
                           Added isEccOnly fields to Requests to indicate that RSA information should not be sent back
              31 Oct 2023  Include version.proto and add Version to AutomatorResponse
              08 Nov 2023  Changed field names containing "Ec" to "Ecc"
"""

import builtins
import collections.abc
import enterprise_pb2
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import ssocloud_pb2
import sys
import typing
import version_pb2

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class _SsoAuthenticationProtocolType:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _SsoAuthenticationProtocolTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_SsoAuthenticationProtocolType.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    UNKNOWN_PROTOCOL: _SsoAuthenticationProtocolType.ValueType  # 0
    SAML2: _SsoAuthenticationProtocolType.ValueType  # 1
    """The SAML2 protocol"""

class SsoAuthenticationProtocolType(_SsoAuthenticationProtocolType, metaclass=_SsoAuthenticationProtocolTypeEnumTypeWrapper):
    """*
    This enumerates the SSO Authentication protocols we support.
    We plan to support more protocols in the future.
    """

UNKNOWN_PROTOCOL: SsoAuthenticationProtocolType.ValueType  # 0
SAML2: SsoAuthenticationProtocolType.ValueType  # 1
"""The SAML2 protocol"""
global___SsoAuthenticationProtocolType = SsoAuthenticationProtocolType

class _CertificateFormat:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _CertificateFormatEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_CertificateFormat.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    UNKNOWN_FORMAT: _CertificateFormat.ValueType  # 0
    PKCS12: _CertificateFormat.ValueType  # 1
    """.pfx or .p12 format commonly used for certificates"""
    JKS: _CertificateFormat.ValueType  # 2
    """.jks format commonly used in older Java implementations"""

class CertificateFormat(_CertificateFormat, metaclass=_CertificateFormatEnumTypeWrapper): ...

UNKNOWN_FORMAT: CertificateFormat.ValueType  # 0
PKCS12: CertificateFormat.ValueType  # 1
""".pfx or .p12 format commonly used for certificates"""
JKS: CertificateFormat.ValueType  # 2
""".jks format commonly used in older Java implementations"""
global___CertificateFormat = CertificateFormat

class _SkillType:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _SkillTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_SkillType.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    UNKNOWN_SKILL_TYPE: _SkillType.ValueType  # 0
    DEVICE_APPROVAL: _SkillType.ValueType  # 1
    TEAM_APPROVAL: _SkillType.ValueType  # 2
    TEAM_FOR_USER_APPROVAL: _SkillType.ValueType  # 3

class SkillType(_SkillType, metaclass=_SkillTypeEnumTypeWrapper):
    """=====================================================================================
    The entries above are used when sending messages to an Automator.

    The entries below are used when a client (Console or Commander) is configuring
    or viewing the status of an Automator.
    =====================================================================================

    *
    These are the known skill types.
    """

UNKNOWN_SKILL_TYPE: SkillType.ValueType  # 0
DEVICE_APPROVAL: SkillType.ValueType  # 1
TEAM_APPROVAL: SkillType.ValueType  # 2
TEAM_FOR_USER_APPROVAL: SkillType.ValueType  # 3
global___SkillType = SkillType

class _AutomatorState:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _AutomatorStateEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_AutomatorState.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    UNKNOWN_STATE: _AutomatorState.ValueType  # 0
    RUNNING: _AutomatorState.ValueType  # 1
    """The Automator is running"""
    ERROR: _AutomatorState.ValueType  # 2
    """The Automator is seriously hosed"""
    NEEDS_INITIALIZATION: _AutomatorState.ValueType  # 3
    """The Automator is created but needs to be initialized"""
    NEEDS_CRYPTO_STEP_1: _AutomatorState.ValueType  # 4
    """The Automator needs the client to initiate a key exchange"""
    NEEDS_CRYPTO_STEP_2: _AutomatorState.ValueType  # 5
    """The Automator needs the client to do the second step of the key exchange"""

class AutomatorState(_AutomatorState, metaclass=_AutomatorStateEnumTypeWrapper):
    """*
    AutomatorState (enum)

    Provides the state of the Automator - part of the status.
    """

UNKNOWN_STATE: AutomatorState.ValueType  # 0
RUNNING: AutomatorState.ValueType  # 1
"""The Automator is running"""
ERROR: AutomatorState.ValueType  # 2
"""The Automator is seriously hosed"""
NEEDS_INITIALIZATION: AutomatorState.ValueType  # 3
"""The Automator is created but needs to be initialized"""
NEEDS_CRYPTO_STEP_1: AutomatorState.ValueType  # 4
"""The Automator needs the client to initiate a key exchange"""
NEEDS_CRYPTO_STEP_2: AutomatorState.ValueType  # 5
"""The Automator needs the client to do the second step of the key exchange"""
global___AutomatorState = AutomatorState

@typing.final
class AutomatorSettingValue(google.protobuf.message.Message):
    """*
    This represents one setting and its value.
    The value is always a string but it is dynamically typed.
    The dataType property determines what type it is (boolean, string, integer, ...) and thus how it should be interpreted.
    Other properties such as "editable" and "fromFile" help the client determine whether the user can edit the value and
    what type of interface to present to the user (text box, file upload, etc.).
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SETTINGID_FIELD_NUMBER: builtins.int
    SETTINGTYPEID_FIELD_NUMBER: builtins.int
    SETTINGTAG_FIELD_NUMBER: builtins.int
    SETTINGNAME_FIELD_NUMBER: builtins.int
    SETTINGVALUE_FIELD_NUMBER: builtins.int
    DATATYPE_FIELD_NUMBER: builtins.int
    LASTMODIFIED_FIELD_NUMBER: builtins.int
    FROMFILE_FIELD_NUMBER: builtins.int
    ENCRYPTED_FIELD_NUMBER: builtins.int
    ENCODED_FIELD_NUMBER: builtins.int
    EDITABLE_FIELD_NUMBER: builtins.int
    TRANSLATED_FIELD_NUMBER: builtins.int
    USERVISIBLE_FIELD_NUMBER: builtins.int
    REQUIRED_FIELD_NUMBER: builtins.int
    settingId: builtins.int
    """The ID of this particular setting"""
    settingTypeId: builtins.int
    """The ID of the type of this setting (AutomatorSettingType)"""
    settingTag: builtins.str
    """A computer-readable tag that corresponds to the setting type (such as automator_name or email_mapping)"""
    settingName: builtins.str
    """A human translation of the computer-readable tag into the client's locale"""
    settingValue: builtins.str
    """A string version of the value.  Use the dataType field to see how to interpret it."""
    dataType: ssocloud_pb2.DataType.ValueType
    """The data type: string, int, long, boolean, etc"""
    lastModified: builtins.str
    """ISO-8661 UTC date time string"""
    fromFile: builtins.bool
    """Whether the value of this field should be the contents of a file"""
    encrypted: builtins.bool
    """Whether the value of this field is encrypted"""
    encoded: builtins.bool
    """Whether the value of this field is Base64-encoded"""
    editable: builtins.bool
    """Whether the value of this field is user-editable"""
    translated: builtins.bool
    """Whether the value should be translated into the locale language (rare)"""
    userVisible: builtins.bool
    """Whether this value is displayed to the user"""
    required: builtins.bool
    """Whether this setting is required"""
    def __init__(
        self,
        *,
        settingId: builtins.int = ...,
        settingTypeId: builtins.int = ...,
        settingTag: builtins.str = ...,
        settingName: builtins.str = ...,
        settingValue: builtins.str = ...,
        dataType: ssocloud_pb2.DataType.ValueType = ...,
        lastModified: builtins.str = ...,
        fromFile: builtins.bool = ...,
        encrypted: builtins.bool = ...,
        encoded: builtins.bool = ...,
        editable: builtins.bool = ...,
        translated: builtins.bool = ...,
        userVisible: builtins.bool = ...,
        required: builtins.bool = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["dataType", b"dataType", "editable", b"editable", "encoded", b"encoded", "encrypted", b"encrypted", "fromFile", b"fromFile", "lastModified", b"lastModified", "required", b"required", "settingId", b"settingId", "settingName", b"settingName", "settingTag", b"settingTag", "settingTypeId", b"settingTypeId", "settingValue", b"settingValue", "translated", b"translated", "userVisible", b"userVisible"]) -> None: ...

global___AutomatorSettingValue = AutomatorSettingValue

@typing.final
class ApproveDeviceRequest(google.protobuf.message.Message):
    """*
    ApproveDeviceRequest
    This is used to ask Automator to approve a user's device.
    It requires a SAML Authentication response, or the equivalent.

    @return an AutomatorResponse containing an ApproveDeviceResponse
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    AUTOMATORID_FIELD_NUMBER: builtins.int
    SSOAUTHENTICATIONPROTOCOLTYPE_FIELD_NUMBER: builtins.int
    AUTHMESSAGE_FIELD_NUMBER: builtins.int
    EMAIL_FIELD_NUMBER: builtins.int
    DEVICEPUBLICKEY_FIELD_NUMBER: builtins.int
    SERVERECCPUBLICKEYID_FIELD_NUMBER: builtins.int
    USERENCRYPTEDDATAKEY_FIELD_NUMBER: builtins.int
    USERENCRYPTEDDATAKEYTYPE_FIELD_NUMBER: builtins.int
    IPADDRESS_FIELD_NUMBER: builtins.int
    ISTESTING_FIELD_NUMBER: builtins.int
    ISECCONLY_FIELD_NUMBER: builtins.int
    automatorId: builtins.int
    """The ID of the automator instance being contacted."""
    ssoAuthenticationProtocolType: global___SsoAuthenticationProtocolType.ValueType
    """SAML2 or other."""
    authMessage: builtins.str
    """The SAML (or other) authentication message sent from the IdP to Keeper."""
    email: builtins.str
    """Email address of the user being authenticated."""
    devicePublicKey: builtins.bytes
    """The ECC public key of the device being approved."""
    serverEccPublicKeyId: builtins.int
    """This is included in every request."""
    userEncryptedDataKey: builtins.bytes
    """The user_encrypted_data_key encrypted with the enterprise data key."""
    userEncryptedDataKeyType: enterprise_pb2.EncryptedKeyType.ValueType
    """The type of the key, normally 3 = ENCRYPTED_BY_DATA_KEY_GCM."""
    ipAddress: builtins.str
    """The ip address of the user requesting approval."""
    isTesting: builtins.bool
    """True if this call is part of a unit test."""
    isEccOnly: builtins.bool
    """If true, do not send any RSA-encrypted results."""
    def __init__(
        self,
        *,
        automatorId: builtins.int = ...,
        ssoAuthenticationProtocolType: global___SsoAuthenticationProtocolType.ValueType = ...,
        authMessage: builtins.str = ...,
        email: builtins.str = ...,
        devicePublicKey: builtins.bytes = ...,
        serverEccPublicKeyId: builtins.int = ...,
        userEncryptedDataKey: builtins.bytes = ...,
        userEncryptedDataKeyType: enterprise_pb2.EncryptedKeyType.ValueType = ...,
        ipAddress: builtins.str = ...,
        isTesting: builtins.bool = ...,
        isEccOnly: builtins.bool = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["authMessage", b"authMessage", "automatorId", b"automatorId", "devicePublicKey", b"devicePublicKey", "email", b"email", "ipAddress", b"ipAddress", "isEccOnly", b"isEccOnly", "isTesting", b"isTesting", "serverEccPublicKeyId", b"serverEccPublicKeyId", "ssoAuthenticationProtocolType", b"ssoAuthenticationProtocolType", "userEncryptedDataKey", b"userEncryptedDataKey", "userEncryptedDataKeyType", b"userEncryptedDataKeyType"]) -> None: ...

global___ApproveDeviceRequest = ApproveDeviceRequest

@typing.final
class SetupRequest(google.protobuf.message.Message):
    """*
    SetupRequest
    In NEEDS_CRYPTO_STEP_1, this causes the automator to reply with the automator public ECC key.
    In NEEDS_CRYPTO_STEP_2, this causes the automator to accept the ec_enterprise_private_key encrypted with the automator's public ECC key.

    The client should check the automatorState in the AutomatorResponse to see what the next step should be.

    @return an AutomatorResponse containing  StatusResponse
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    AUTOMATORID_FIELD_NUMBER: builtins.int
    SERVERECCPUBLICKEYID_FIELD_NUMBER: builtins.int
    AUTOMATORSTATE_FIELD_NUMBER: builtins.int
    ENCRYPTEDENTERPRISEPRIVATEECCKEY_FIELD_NUMBER: builtins.int
    ENCRYPTEDENTERPRISEPRIVATERSAKEY_FIELD_NUMBER: builtins.int
    AUTOMATORSKILLS_FIELD_NUMBER: builtins.int
    ENCRYPTEDTREEKEY_FIELD_NUMBER: builtins.int
    ISECCONLY_FIELD_NUMBER: builtins.int
    automatorId: builtins.int
    """The ID of the automator instance being contacted."""
    serverEccPublicKeyId: builtins.int
    """This is included in every request"""
    automatorState: global___AutomatorState.ValueType
    """Should be NEEDS_CRYPTO_STEP_1 or NEEDS_CRYPTO_STEP_2"""
    encryptedEnterprisePrivateEccKey: builtins.bytes
    """In NEEDS_CRYPTO_STEP_2, send in the ECC enterprisePrivateKey encrypted with the automator's public key"""
    encryptedEnterprisePrivateRsaKey: builtins.bytes
    """In NEEDS_CRYPTO_STEP_2, send in the RSA enterprisePrivateKey encrypted with the automator's public key"""
    encryptedTreeKey: builtins.bytes
    """The enterprise's treeKey encrypted with the automator's public key"""
    isEccOnly: builtins.bool
    """If true, do not send any RSA-encrypted results"""
    @property
    def automatorSkills(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___AutomatorSkill]:
        """An automator has one or more skills.  Send the entire set, either on the first setup call or the second one"""

    def __init__(
        self,
        *,
        automatorId: builtins.int = ...,
        serverEccPublicKeyId: builtins.int = ...,
        automatorState: global___AutomatorState.ValueType = ...,
        encryptedEnterprisePrivateEccKey: builtins.bytes = ...,
        encryptedEnterprisePrivateRsaKey: builtins.bytes = ...,
        automatorSkills: collections.abc.Iterable[global___AutomatorSkill] | None = ...,
        encryptedTreeKey: builtins.bytes = ...,
        isEccOnly: builtins.bool = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["automatorId", b"automatorId", "automatorSkills", b"automatorSkills", "automatorState", b"automatorState", "encryptedEnterprisePrivateEccKey", b"encryptedEnterprisePrivateEccKey", "encryptedEnterprisePrivateRsaKey", b"encryptedEnterprisePrivateRsaKey", "encryptedTreeKey", b"encryptedTreeKey", "isEccOnly", b"isEccOnly", "serverEccPublicKeyId", b"serverEccPublicKeyId"]) -> None: ...

global___SetupRequest = SetupRequest

@typing.final
class StatusRequest(google.protobuf.message.Message):
    """*
    StatusRequest
    This is used to ask the Automator instance for its status via an authenticated REST call.
    @return an AutomatorResponse containing  StatusResponse
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    AUTOMATORID_FIELD_NUMBER: builtins.int
    SERVERECCPUBLICKEYID_FIELD_NUMBER: builtins.int
    ISECCONLY_FIELD_NUMBER: builtins.int
    automatorId: builtins.int
    """The ID of the automator instance being contacted."""
    serverEccPublicKeyId: builtins.int
    """This is included in every request"""
    isEccOnly: builtins.bool
    """If true, do not send any RSA-encrypted results"""
    def __init__(
        self,
        *,
        automatorId: builtins.int = ...,
        serverEccPublicKeyId: builtins.int = ...,
        isEccOnly: builtins.bool = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["automatorId", b"automatorId", "isEccOnly", b"isEccOnly", "serverEccPublicKeyId", b"serverEccPublicKeyId"]) -> None: ...

global___StatusRequest = StatusRequest

@typing.final
class InitializeRequest(google.protobuf.message.Message):
    """*
    InitializeRequest
    This is used to Initialize the Automator instance via an authenticated REST call.
    Updated for Automator 2.0 by adding 9 new configuration parameters.
    Updated for Automator 2.2 by adding 2 new configuration parameters.

    @return an AutomatorResponse containing a StatusResponse
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    AUTOMATORID_FIELD_NUMBER: builtins.int
    IDPMETADATA_FIELD_NUMBER: builtins.int
    IDPSIGNINGCERTIFICATE_FIELD_NUMBER: builtins.int
    SSOENTITYID_FIELD_NUMBER: builtins.int
    EMAILMAPPING_FIELD_NUMBER: builtins.int
    FIRSTNAMEMAPPING_FIELD_NUMBER: builtins.int
    LASTNAMEMAPPING_FIELD_NUMBER: builtins.int
    DISABLED_FIELD_NUMBER: builtins.int
    SERVERECCPUBLICKEYID_FIELD_NUMBER: builtins.int
    CONFIG_FIELD_NUMBER: builtins.int
    SSLMODE_FIELD_NUMBER: builtins.int
    PERSISTSTATE_FIELD_NUMBER: builtins.int
    DISABLESNICHECK_FIELD_NUMBER: builtins.int
    SSLCERTIFICATEFILENAME_FIELD_NUMBER: builtins.int
    SSLCERTIFICATEFILEPASSWORD_FIELD_NUMBER: builtins.int
    SSLCERTIFICATEKEYPASSWORD_FIELD_NUMBER: builtins.int
    SSLCERTIFICATECONTENTS_FIELD_NUMBER: builtins.int
    AUTOMATORHOST_FIELD_NUMBER: builtins.int
    AUTOMATORPORT_FIELD_NUMBER: builtins.int
    IPALLOW_FIELD_NUMBER: builtins.int
    IPDENY_FIELD_NUMBER: builtins.int
    ISECCONLY_FIELD_NUMBER: builtins.int
    automatorId: builtins.int
    """Uniquely identifies this service"""
    idpMetadata: builtins.str
    """The IDP metadata for this SSO node.  Needed to decrypt the SAML login response."""
    idpSigningCertificate: builtins.bytes
    """UTF8 bytes of an X509Certificate (.cer or .crt file, DER-encoded).  If empty, we use the certificate in the IdP metadata."""
    ssoEntityId: builtins.str
    """The entityId of the SSO instance associated with this automator.  Needed for SAML validation"""
    emailMapping: builtins.str
    """The field where the IdP puts the user's email"""
    firstnameMapping: builtins.str
    """The field where the IdP puts the user's first name"""
    lastnameMapping: builtins.str
    """The field where the IdP puts the user's last name"""
    disabled: builtins.bool
    """If true, will disable the automator after initialization.  Usually you want it to be enabled so leave this false."""
    serverEccPublicKeyId: builtins.int
    """This is included in every request"""
    config: builtins.bytes
    """The encoded, encrypted configuration, if it has been previously stored by the Automator on the server."""
    sslMode: builtins.str
    """"certificate", "self-signed", or "none" """
    persistState: builtins.bool
    """true if the Automator should store its configuration in Keeper"""
    disableSniCheck: builtins.bool
    """if true, SNI check is disabled for incoming connections"""
    sslCertificateFilename: builtins.str
    """The name of the SSL file"""
    sslCertificateFilePassword: builtins.str
    """The password on the SSL file, if any"""
    sslCertificateKeyPassword: builtins.str
    """The password on the key in the SSL file, if any"""
    sslCertificateContents: builtins.bytes
    """The contents of the SSL file"""
    automatorHost: builtins.str
    """The hostname of the Automator instance"""
    automatorPort: builtins.str
    """The port number of the Automator instance, as a string"""
    ipAllow: builtins.str
    """A list of IP addresses and/or ranges to allow"""
    ipDeny: builtins.str
    """A list of IP addresses and/or ranges to deny"""
    isEccOnly: builtins.bool
    """If true, do not send any RSA-encrypted results"""
    def __init__(
        self,
        *,
        automatorId: builtins.int = ...,
        idpMetadata: builtins.str = ...,
        idpSigningCertificate: builtins.bytes = ...,
        ssoEntityId: builtins.str = ...,
        emailMapping: builtins.str = ...,
        firstnameMapping: builtins.str = ...,
        lastnameMapping: builtins.str = ...,
        disabled: builtins.bool = ...,
        serverEccPublicKeyId: builtins.int = ...,
        config: builtins.bytes = ...,
        sslMode: builtins.str = ...,
        persistState: builtins.bool = ...,
        disableSniCheck: builtins.bool = ...,
        sslCertificateFilename: builtins.str = ...,
        sslCertificateFilePassword: builtins.str = ...,
        sslCertificateKeyPassword: builtins.str = ...,
        sslCertificateContents: builtins.bytes = ...,
        automatorHost: builtins.str = ...,
        automatorPort: builtins.str = ...,
        ipAllow: builtins.str = ...,
        ipDeny: builtins.str = ...,
        isEccOnly: builtins.bool = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["automatorHost", b"automatorHost", "automatorId", b"automatorId", "automatorPort", b"automatorPort", "config", b"config", "disableSniCheck", b"disableSniCheck", "disabled", b"disabled", "emailMapping", b"emailMapping", "firstnameMapping", b"firstnameMapping", "idpMetadata", b"idpMetadata", "idpSigningCertificate", b"idpSigningCertificate", "ipAllow", b"ipAllow", "ipDeny", b"ipDeny", "isEccOnly", b"isEccOnly", "lastnameMapping", b"lastnameMapping", "persistState", b"persistState", "serverEccPublicKeyId", b"serverEccPublicKeyId", "sslCertificateContents", b"sslCertificateContents", "sslCertificateFilePassword", b"sslCertificateFilePassword", "sslCertificateFilename", b"sslCertificateFilename", "sslCertificateKeyPassword", b"sslCertificateKeyPassword", "sslMode", b"sslMode", "ssoEntityId", b"ssoEntityId"]) -> None: ...

global___InitializeRequest = InitializeRequest

@typing.final
class NotInitializedResponse(google.protobuf.message.Message):
    """*
    NotInitializedResponse
    The Automator instance replies with this message if it has not been initialized.
    The certificate is most likely the SSL certificate of the Automator.
    The certificate will be passed to the corresponding Cloud SSO instance and used to sign the IdP messages.

    This message will be encrypted with the ECC public key whose ID is indicated in the request received from Keeper.
    All other messages are encrypted with the automatorTransmissionKey.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    AUTOMATORTRANSMISSIONKEY_FIELD_NUMBER: builtins.int
    SIGNINGCERTIFICATE_FIELD_NUMBER: builtins.int
    SIGNINGCERTIFICATEFILENAME_FIELD_NUMBER: builtins.int
    SIGNINGCERTIFICATEPASSWORD_FIELD_NUMBER: builtins.int
    SIGNINGKEYPASSWORD_FIELD_NUMBER: builtins.int
    SIGNINGCERTIFICATEFORMAT_FIELD_NUMBER: builtins.int
    AUTOMATORPUBLICKEY_FIELD_NUMBER: builtins.int
    CONFIG_FIELD_NUMBER: builtins.int
    automatorTransmissionKey: builtins.bytes
    """This indicates that this automator instance is not initialized and that Keeper should subsequently send a message to initialize it."""
    signingCertificate: builtins.bytes
    """UTF-8 bytes of a .pfx file containing an SSL certificate (public/private key pair) or the equivalent."""
    signingCertificateFilename: builtins.str
    """filename of the signing cert"""
    signingCertificatePassword: builtins.str
    """password for the certificate file (may be blank or empty).  Required if the file has a password."""
    signingKeyPassword: builtins.str
    """password for the key inside the file (may be blank or empty).  Required if the key has a password."""
    signingCertificateFormat: global___CertificateFormat.ValueType
    """Nominally PKCS12 (pfx) but we may allow JKS or other formats in the future."""
    automatorPublicKey: builtins.bytes
    """ECC public key used to encrypt info to be sent to this Automator (unique to each Automator and not stored in Keeper)"""
    config: builtins.bytes
    """If set, Keeperapp should store this configuration in the Automator."""
    def __init__(
        self,
        *,
        automatorTransmissionKey: builtins.bytes = ...,
        signingCertificate: builtins.bytes = ...,
        signingCertificateFilename: builtins.str = ...,
        signingCertificatePassword: builtins.str = ...,
        signingKeyPassword: builtins.str = ...,
        signingCertificateFormat: global___CertificateFormat.ValueType = ...,
        automatorPublicKey: builtins.bytes = ...,
        config: builtins.bytes = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["automatorPublicKey", b"automatorPublicKey", "automatorTransmissionKey", b"automatorTransmissionKey", "config", b"config", "signingCertificate", b"signingCertificate", "signingCertificateFilename", b"signingCertificateFilename", "signingCertificateFormat", b"signingCertificateFormat", "signingCertificatePassword", b"signingCertificatePassword", "signingKeyPassword", b"signingKeyPassword"]) -> None: ...

global___NotInitializedResponse = NotInitializedResponse

@typing.final
class AutomatorResponse(google.protobuf.message.Message):
    """*
    AutomatorResponse
    This is always the response to an API request.
    Just as in a Keeperapp client, it is encrypted with the one-time transmissionKey sent with the ApiRequest.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    AUTOMATORID_FIELD_NUMBER: builtins.int
    ENABLED_FIELD_NUMBER: builtins.int
    TIMESTAMP_FIELD_NUMBER: builtins.int
    APPROVEDEVICE_FIELD_NUMBER: builtins.int
    STATUS_FIELD_NUMBER: builtins.int
    NOTINITIALIZED_FIELD_NUMBER: builtins.int
    ERROR_FIELD_NUMBER: builtins.int
    APPROVETEAMSFORUSER_FIELD_NUMBER: builtins.int
    APPROVETEAMS_FIELD_NUMBER: builtins.int
    AUTOMATORSTATE_FIELD_NUMBER: builtins.int
    AUTOMATORPUBLICECCKEY_FIELD_NUMBER: builtins.int
    VERSION_FIELD_NUMBER: builtins.int
    automatorId: builtins.int
    """The ID of this automator instance"""
    enabled: builtins.bool
    """True if this instance is enabled.  It never approves devices if it is not enabled"""
    timestamp: builtins.int
    """Unix time UTC = System.currentTimeMillis()"""
    automatorState: global___AutomatorState.ValueType
    """The state of the automator"""
    automatorPublicEccKey: builtins.bytes
    """The automator's public key - sent only if automatorState == NEEDS_CRYPTO_STEP_1"""
    @property
    def approveDevice(self) -> global___ApproveDeviceResponse:
        """Included if ApproveDeviceRequest was called and there was no error."""

    @property
    def status(self) -> global___StatusResponse:
        """Included if /initialize or /status was called and there was no error."""

    @property
    def notInitialized(self) -> global___NotInitializedResponse:
        """Included if the Automator needs to be initialized"""

    @property
    def error(self) -> global___ErrorResponse:
        """Included if the Automator encountered an error during processing."""

    @property
    def approveTeamsForUser(self) -> global___ApproveTeamsForUserResponse:
        """Included if ApproveTeamsForUserRequest was called and there was no error."""

    @property
    def approveTeams(self) -> global___ApproveTeamsResponse:
        """Included if ApproveTeamsRequest was called and there was no error."""

    @property
    def version(self) -> version_pb2.Version:
        """Automator version.  Automators v3.1.0 and above know about this field."""

    def __init__(
        self,
        *,
        automatorId: builtins.int = ...,
        enabled: builtins.bool = ...,
        timestamp: builtins.int = ...,
        approveDevice: global___ApproveDeviceResponse | None = ...,
        status: global___StatusResponse | None = ...,
        notInitialized: global___NotInitializedResponse | None = ...,
        error: global___ErrorResponse | None = ...,
        approveTeamsForUser: global___ApproveTeamsForUserResponse | None = ...,
        approveTeams: global___ApproveTeamsResponse | None = ...,
        automatorState: global___AutomatorState.ValueType = ...,
        automatorPublicEccKey: builtins.bytes = ...,
        version: version_pb2.Version | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["approveDevice", b"approveDevice", "approveTeams", b"approveTeams", "approveTeamsForUser", b"approveTeamsForUser", "error", b"error", "notInitialized", b"notInitialized", "response", b"response", "status", b"status", "version", b"version"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["approveDevice", b"approveDevice", "approveTeams", b"approveTeams", "approveTeamsForUser", b"approveTeamsForUser", "automatorId", b"automatorId", "automatorPublicEccKey", b"automatorPublicEccKey", "automatorState", b"automatorState", "enabled", b"enabled", "error", b"error", "notInitialized", b"notInitialized", "response", b"response", "status", b"status", "timestamp", b"timestamp", "version", b"version"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["response", b"response"]) -> typing.Literal["approveDevice", "status", "notInitialized", "error", "approveTeamsForUser", "approveTeams"] | None: ...

global___AutomatorResponse = AutomatorResponse

@typing.final
class ApproveDeviceResponse(google.protobuf.message.Message):
    """*
    ApproveDeviceResponse
    Includes information about whether the device was approved or not.
    There will be a message in the 'message' field of the AutomatorResponse if the device was not approved.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    APPROVED_FIELD_NUMBER: builtins.int
    ENCRYPTEDUSERDATAKEY_FIELD_NUMBER: builtins.int
    MESSAGE_FIELD_NUMBER: builtins.int
    ENCRYPTEDUSERDATAKEYTYPE_FIELD_NUMBER: builtins.int
    approved: builtins.bool
    """True if the device is to be approved"""
    encryptedUserDataKey: builtins.bytes
    """The enterprise data key encrypted with the ECC device public key, if it was approved"""
    message: builtins.str
    """If device was not approved, will contain a message explaining why"""
    encryptedUserDataKeyType: enterprise_pb2.EncryptedKeyType.ValueType
    """The type of the encrypted User data key"""
    def __init__(
        self,
        *,
        approved: builtins.bool = ...,
        encryptedUserDataKey: builtins.bytes = ...,
        message: builtins.str = ...,
        encryptedUserDataKeyType: enterprise_pb2.EncryptedKeyType.ValueType = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["approved", b"approved", "encryptedUserDataKey", b"encryptedUserDataKey", "encryptedUserDataKeyType", b"encryptedUserDataKeyType", "message", b"message"]) -> None: ...

global___ApproveDeviceResponse = ApproveDeviceResponse

@typing.final
class StatusResponse(google.protobuf.message.Message):
    """*
    StatusResponse
    Includes information about the status of the Automator instance, if it has been initialized.
    There will be a message in the 'message' field of the AutomatorResponse if there was an internal error.
    If this is in response to an 'initializeRequest' message it will contain a NotInitializedResponse that
    contains information about the signing certificate used by the Automator.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    INITIALIZED_FIELD_NUMBER: builtins.int
    ENABLEDTIMESTAMP_FIELD_NUMBER: builtins.int
    INITIALIZEDTIMESTAMP_FIELD_NUMBER: builtins.int
    UPDATEDTIMESTAMP_FIELD_NUMBER: builtins.int
    NUMBEROFDEVICESAPPROVED_FIELD_NUMBER: builtins.int
    NUMBEROFDEVICESDENIED_FIELD_NUMBER: builtins.int
    NUMBEROFERRORS_FIELD_NUMBER: builtins.int
    SSLCERTIFICATEEXPIRATION_FIELD_NUMBER: builtins.int
    NOTINITIALIZEDRESPONSE_FIELD_NUMBER: builtins.int
    CONFIG_FIELD_NUMBER: builtins.int
    NUMBEROFTEAMMEMBERSHIPSAPPROVED_FIELD_NUMBER: builtins.int
    NUMBEROFTEAMMEMBERSHIPSDENIED_FIELD_NUMBER: builtins.int
    NUMBEROFTEAMSAPPROVED_FIELD_NUMBER: builtins.int
    NUMBEROFTEAMSDENIED_FIELD_NUMBER: builtins.int
    initialized: builtins.bool
    """True if this automator has been initialized"""
    enabledTimestamp: builtins.int
    """Unix time when this instance was last enabled or disabled"""
    initializedTimestamp: builtins.int
    """Unix time - UTC.  Will be zero if not yet initialized"""
    updatedTimestamp: builtins.int
    """Unix time when this instance was last updated"""
    numberOfDevicesApproved: builtins.int
    """Number of devices approved since initialization"""
    numberOfDevicesDenied: builtins.int
    """Number of devices denied since initialization"""
    numberOfErrors: builtins.int
    """Number of processing errors encountered since initialization"""
    sslCertificateExpiration: builtins.int
    """Unix time when the SSL certificate will expire."""
    config: builtins.bytes
    """If the config has been changed, this is the encrypted, encoded config and it should be stored on the server for future retrieval."""
    numberOfTeamMembershipsApproved: builtins.int
    """Number of team memberships approved since initialization"""
    numberOfTeamMembershipsDenied: builtins.int
    """Number of team memberships denied since initialization"""
    numberOfTeamsApproved: builtins.int
    """Number of teams approved since initialization"""
    numberOfTeamsDenied: builtins.int
    """Number of teams denied since initialization"""
    @property
    def notInitializedResponse(self) -> global___NotInitializedResponse:
        """If this is in response to an initialize request, this field will contain information aobut the Signing Certificate being used by Automator.  Otherwise it will be empty."""

    def __init__(
        self,
        *,
        initialized: builtins.bool = ...,
        enabledTimestamp: builtins.int = ...,
        initializedTimestamp: builtins.int = ...,
        updatedTimestamp: builtins.int = ...,
        numberOfDevicesApproved: builtins.int = ...,
        numberOfDevicesDenied: builtins.int = ...,
        numberOfErrors: builtins.int = ...,
        sslCertificateExpiration: builtins.int = ...,
        notInitializedResponse: global___NotInitializedResponse | None = ...,
        config: builtins.bytes = ...,
        numberOfTeamMembershipsApproved: builtins.int = ...,
        numberOfTeamMembershipsDenied: builtins.int = ...,
        numberOfTeamsApproved: builtins.int = ...,
        numberOfTeamsDenied: builtins.int = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["notInitializedResponse", b"notInitializedResponse"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["config", b"config", "enabledTimestamp", b"enabledTimestamp", "initialized", b"initialized", "initializedTimestamp", b"initializedTimestamp", "notInitializedResponse", b"notInitializedResponse", "numberOfDevicesApproved", b"numberOfDevicesApproved", "numberOfDevicesDenied", b"numberOfDevicesDenied", "numberOfErrors", b"numberOfErrors", "numberOfTeamMembershipsApproved", b"numberOfTeamMembershipsApproved", "numberOfTeamMembershipsDenied", b"numberOfTeamMembershipsDenied", "numberOfTeamsApproved", b"numberOfTeamsApproved", "numberOfTeamsDenied", b"numberOfTeamsDenied", "sslCertificateExpiration", b"sslCertificateExpiration", "updatedTimestamp", b"updatedTimestamp"]) -> None: ...

global___StatusResponse = StatusResponse

@typing.final
class ErrorResponse(google.protobuf.message.Message):
    """*
    ErrorResponse
    Includes error information, if the Automator encountered an error during processing.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    MESSAGE_FIELD_NUMBER: builtins.int
    message: builtins.str
    """An error message"""
    def __init__(
        self,
        *,
        message: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["message", b"message"]) -> None: ...

global___ErrorResponse = ErrorResponse

@typing.final
class LogEntry(google.protobuf.message.Message):
    """*
    One entry from the log.
    Normally, log entries will be sorted in reverse chronological order (newest first).

    Included in AdminResponse.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SERVERTIME_FIELD_NUMBER: builtins.int
    MESSAGELEVEL_FIELD_NUMBER: builtins.int
    COMPONENT_FIELD_NUMBER: builtins.int
    MESSAGE_FIELD_NUMBER: builtins.int
    serverTime: builtins.str
    """Time on the server, in ISO-8601 format"""
    messageLevel: builtins.str
    """INFO, DEBUG, ERROR, etc."""
    component: builtins.str
    """The component doing the logging, such as AutomatorStatus"""
    message: builtins.str
    """The log entry"""
    def __init__(
        self,
        *,
        serverTime: builtins.str = ...,
        messageLevel: builtins.str = ...,
        component: builtins.str = ...,
        message: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["component", b"component", "message", b"message", "messageLevel", b"messageLevel", "serverTime", b"serverTime"]) -> None: ...

global___LogEntry = LogEntry

@typing.final
class AdminResponse(google.protobuf.message.Message):
    """*
    AdminResponse

    This is sent in reply to an Admin request.
    There can be more than one Automator on a Node so that's why this is a multi-response.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SUCCESS_FIELD_NUMBER: builtins.int
    MESSAGE_FIELD_NUMBER: builtins.int
    AUTOMATORINFO_FIELD_NUMBER: builtins.int
    success: builtins.bool
    """Was the call successful?"""
    message: builtins.str
    """If non-empty, should be displayed to the user"""
    @property
    def automatorInfo(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___AutomatorInfo]:
        """Information requested by the client"""

    def __init__(
        self,
        *,
        success: builtins.bool = ...,
        message: builtins.str = ...,
        automatorInfo: collections.abc.Iterable[global___AutomatorInfo] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["automatorInfo", b"automatorInfo", "message", b"message", "success", b"success"]) -> None: ...

global___AdminResponse = AdminResponse

@typing.final
class AutomatorInfo(google.protobuf.message.Message):
    """*
    Information about an automator for a client that is configuring an Automator.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    AUTOMATORID_FIELD_NUMBER: builtins.int
    NODEID_FIELD_NUMBER: builtins.int
    NAME_FIELD_NUMBER: builtins.int
    ENABLED_FIELD_NUMBER: builtins.int
    URL_FIELD_NUMBER: builtins.int
    AUTOMATORSKILLS_FIELD_NUMBER: builtins.int
    AUTOMATORSETTINGVALUES_FIELD_NUMBER: builtins.int
    STATUS_FIELD_NUMBER: builtins.int
    LOGENTRIES_FIELD_NUMBER: builtins.int
    AUTOMATORSTATE_FIELD_NUMBER: builtins.int
    VERSION_FIELD_NUMBER: builtins.int
    automatorId: builtins.int
    """the automator in question"""
    nodeId: builtins.int
    """The ID of the node the automator is attached to"""
    name: builtins.str
    """The name of the automator"""
    enabled: builtins.bool
    """if true, the automator is enabled"""
    url: builtins.str
    """The URL where the automator can be contacted"""
    automatorState: global___AutomatorState.ValueType
    version: builtins.str
    """Version of the Automator instance.  Will be empty if unknown. Automators v3.1.0 and above can supply this value."""
    @property
    def automatorSkills(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___AutomatorSkill]:
        """An automator has one or more skills"""

    @property
    def automatorSettingValues(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___AutomatorSettingValue]:
        """array of settings to display on the Automator Admin page"""

    @property
    def status(self) -> global___StatusResponse:
        """status received from the Automator, if requested."""

    @property
    def logEntries(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___LogEntry]:
        """Entries from the remote Automator log, if requested"""

    def __init__(
        self,
        *,
        automatorId: builtins.int = ...,
        nodeId: builtins.int = ...,
        name: builtins.str = ...,
        enabled: builtins.bool = ...,
        url: builtins.str = ...,
        automatorSkills: collections.abc.Iterable[global___AutomatorSkill] | None = ...,
        automatorSettingValues: collections.abc.Iterable[global___AutomatorSettingValue] | None = ...,
        status: global___StatusResponse | None = ...,
        logEntries: collections.abc.Iterable[global___LogEntry] | None = ...,
        automatorState: global___AutomatorState.ValueType = ...,
        version: builtins.str = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["status", b"status"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["automatorId", b"automatorId", "automatorSettingValues", b"automatorSettingValues", "automatorSkills", b"automatorSkills", "automatorState", b"automatorState", "enabled", b"enabled", "logEntries", b"logEntries", "name", b"name", "nodeId", b"nodeId", "status", b"status", "url", b"url", "version", b"version"]) -> None: ...

global___AutomatorInfo = AutomatorInfo

@typing.final
class AdminCreateAutomatorRequest(google.protobuf.message.Message):
    """*
    AdminCreateAutomatorRequest
    Create an automator on a Node.

    Returns AdminResponse
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    NODEID_FIELD_NUMBER: builtins.int
    NAME_FIELD_NUMBER: builtins.int
    SKILL_FIELD_NUMBER: builtins.int
    nodeId: builtins.int
    """An Automator belongs to a Node"""
    name: builtins.str
    """Name of the automator"""
    @property
    def skill(self) -> global___AutomatorSkill:
        """Initial skill of the Automator.  If none, it will be assigned DEVICE_APPROVAL."""

    def __init__(
        self,
        *,
        nodeId: builtins.int = ...,
        name: builtins.str = ...,
        skill: global___AutomatorSkill | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["skill", b"skill"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["name", b"name", "nodeId", b"nodeId", "skill", b"skill"]) -> None: ...

global___AdminCreateAutomatorRequest = AdminCreateAutomatorRequest

@typing.final
class AdminDeleteAutomatorRequest(google.protobuf.message.Message):
    """*
    AdminDeleteAutomatorRequest

    Delete an automator and its settings.
    Does not notify or affect the actual Automator running at the client site.

    Returns AdminResponse
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    AUTOMATORID_FIELD_NUMBER: builtins.int
    automatorId: builtins.int
    """The automator to delete"""
    def __init__(
        self,
        *,
        automatorId: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["automatorId", b"automatorId"]) -> None: ...

global___AdminDeleteAutomatorRequest = AdminDeleteAutomatorRequest

@typing.final
class AdminGetAutomatorsOnNodeRequest(google.protobuf.message.Message):
    """*
    Retrieve automators on a node.
    The info should also be in enterprise_summary or whatever it is called.

    If you want info on a particular automator, use automator_get.
    Returns AdminResponse
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    NODEID_FIELD_NUMBER: builtins.int
    nodeId: builtins.int
    """The node"""
    def __init__(
        self,
        *,
        nodeId: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["nodeId", b"nodeId"]) -> None: ...

global___AdminGetAutomatorsOnNodeRequest = AdminGetAutomatorsOnNodeRequest

@typing.final
class AdminGetAutomatorsForEnterpriseRequest(google.protobuf.message.Message):
    """*
    Retrieve automators in an enterprise.
    The info should also be in enterprise_summary or whatever it is called.

    If you want info on a particular automator, use automator_get.
    If you want a list of automators on a node, use automator_get_on_node
    Returns AdminResponse
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ENTERPRISEID_FIELD_NUMBER: builtins.int
    enterpriseId: builtins.int
    """The enterprise ID (short form)"""
    def __init__(
        self,
        *,
        enterpriseId: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["enterpriseId", b"enterpriseId"]) -> None: ...

global___AdminGetAutomatorsForEnterpriseRequest = AdminGetAutomatorsForEnterpriseRequest

@typing.final
class AdminGetAutomatorRequest(google.protobuf.message.Message):
    """*
    Retrieve information about a specific automator.

    Returns AdminResponse
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    AUTOMATORID_FIELD_NUMBER: builtins.int
    automatorId: builtins.int
    """The automator whose status is requested"""
    def __init__(
        self,
        *,
        automatorId: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["automatorId", b"automatorId"]) -> None: ...

global___AdminGetAutomatorRequest = AdminGetAutomatorRequest

@typing.final
class AdminEnableAutomatorRequest(google.protobuf.message.Message):
    """*
    Enable or disable an automator.

    Returns AdminResponse
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    AUTOMATORID_FIELD_NUMBER: builtins.int
    ENABLED_FIELD_NUMBER: builtins.int
    automatorId: builtins.int
    """The automator to enable or disable"""
    enabled: builtins.bool
    """If true the Automator is enabled, otherwise it is disabled"""
    def __init__(
        self,
        *,
        automatorId: builtins.int = ...,
        enabled: builtins.bool = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["automatorId", b"automatorId", "enabled", b"enabled"]) -> None: ...

global___AdminEnableAutomatorRequest = AdminEnableAutomatorRequest

@typing.final
class AdminEditAutomatorRequest(google.protobuf.message.Message):
    """*
    Edit settings on the automator.

    If a value is non-empty, it will be set on the Automator.

    Returns AdminResponse with all current settings
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    AUTOMATORID_FIELD_NUMBER: builtins.int
    NAME_FIELD_NUMBER: builtins.int
    ENABLED_FIELD_NUMBER: builtins.int
    URL_FIELD_NUMBER: builtins.int
    SKILLTYPES_FIELD_NUMBER: builtins.int
    AUTOMATORSETTINGVALUES_FIELD_NUMBER: builtins.int
    automatorId: builtins.int
    """The automator being edited"""
    name: builtins.str
    """new name, if non-empty"""
    enabled: builtins.bool
    """enabled or not"""
    url: builtins.str
    """new url, if non-empty"""
    @property
    def skillTypes(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[global___SkillType.ValueType]:
        """The skills of this Automator.  If non-empty, the skills list will be updated to this list"""

    @property
    def automatorSettingValues(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___AutomatorSettingValue]:
        """If non-empty, the setting values will be set to the supplied values"""

    def __init__(
        self,
        *,
        automatorId: builtins.int = ...,
        name: builtins.str = ...,
        enabled: builtins.bool = ...,
        url: builtins.str = ...,
        skillTypes: collections.abc.Iterable[global___SkillType.ValueType] | None = ...,
        automatorSettingValues: collections.abc.Iterable[global___AutomatorSettingValue] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["automatorId", b"automatorId", "automatorSettingValues", b"automatorSettingValues", "enabled", b"enabled", "name", b"name", "skillTypes", b"skillTypes", "url", b"url"]) -> None: ...

global___AdminEditAutomatorRequest = AdminEditAutomatorRequest

@typing.final
class AdminSetupAutomatorRequest(google.protobuf.message.Message):
    """*
    Initiate a setup operation with the automator via Keeper.
    Step 1 is to request the Automator's ECC public key.  Use automatorState = NEEDS_CRYPTO_STEP_1
    Step 2 is to send the ec_enterprise_private_key encrypted with the public key. Use automatorState = NEEDS_CRYPTO_STEP_2

    Returns AdminSetupAutomatorResponse
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    AUTOMATORID_FIELD_NUMBER: builtins.int
    AUTOMATORSTATE_FIELD_NUMBER: builtins.int
    ENCRYPTEDECCENTERPRISEPRIVATEKEY_FIELD_NUMBER: builtins.int
    ENCRYPTEDRSAENTERPRISEPRIVATEKEY_FIELD_NUMBER: builtins.int
    SKILLTYPES_FIELD_NUMBER: builtins.int
    ENCRYPTEDTREEKEY_FIELD_NUMBER: builtins.int
    automatorId: builtins.int
    """The automator being set up"""
    automatorState: global___AutomatorState.ValueType
    """The state of the Automator at this time"""
    encryptedEccEnterprisePrivateKey: builtins.bytes
    """ecc_enterprise_private_key encrypted with the Automator's ECC public key.  Required if state is NEEDS_CRYPTO_STEP_2"""
    encryptedRsaEnterprisePrivateKey: builtins.bytes
    """enterprise_private_key encrypted with the Automator's ECC public key.  Required if state is NEEDS_CRYPTO_STEP_2"""
    encryptedTreeKey: builtins.bytes
    """The enterprise's tree key encrypted with the Automator's ECC public key. Required if state is NEEDS_CRYPTO_STEP_2"""
    @property
    def skillTypes(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[global___SkillType.ValueType]:
        """Which skill(s) do you want to set up?  If empty, defaults to device approval for backward compatibility"""

    def __init__(
        self,
        *,
        automatorId: builtins.int = ...,
        automatorState: global___AutomatorState.ValueType = ...,
        encryptedEccEnterprisePrivateKey: builtins.bytes = ...,
        encryptedRsaEnterprisePrivateKey: builtins.bytes = ...,
        skillTypes: collections.abc.Iterable[global___SkillType.ValueType] | None = ...,
        encryptedTreeKey: builtins.bytes = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["automatorId", b"automatorId", "automatorState", b"automatorState", "encryptedEccEnterprisePrivateKey", b"encryptedEccEnterprisePrivateKey", "encryptedRsaEnterprisePrivateKey", b"encryptedRsaEnterprisePrivateKey", "encryptedTreeKey", b"encryptedTreeKey", "skillTypes", b"skillTypes"]) -> None: ...

global___AdminSetupAutomatorRequest = AdminSetupAutomatorRequest

@typing.final
class AdminSetupAutomatorResponse(google.protobuf.message.Message):
    """*
    The response to an AdminSetupAutomatorRequest.
    The automatorEccPublicKey fields will be non-empty iff the AutomatorState is NEEDS_CRYPTO_STEP_2
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SUCCESS_FIELD_NUMBER: builtins.int
    MESSAGE_FIELD_NUMBER: builtins.int
    AUTOMATORID_FIELD_NUMBER: builtins.int
    AUTOMATORSTATE_FIELD_NUMBER: builtins.int
    AUTOMATORECCPUBLICKEY_FIELD_NUMBER: builtins.int
    success: builtins.bool
    """Successful or not"""
    message: builtins.str
    """Error message if not successful"""
    automatorId: builtins.int
    """The automator being setup"""
    automatorState: global___AutomatorState.ValueType
    """The state of the automator at this time"""
    automatorEccPublicKey: builtins.bytes
    """The public key of this automator in raw (65-byte) format, used for sending data to the automator. Only present if state is NEEDS_CRYPTO_STEP_2"""
    def __init__(
        self,
        *,
        success: builtins.bool = ...,
        message: builtins.str = ...,
        automatorId: builtins.int = ...,
        automatorState: global___AutomatorState.ValueType = ...,
        automatorEccPublicKey: builtins.bytes = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["automatorEccPublicKey", b"automatorEccPublicKey", "automatorId", b"automatorId", "automatorState", b"automatorState", "message", b"message", "success", b"success"]) -> None: ...

global___AdminSetupAutomatorResponse = AdminSetupAutomatorResponse

@typing.final
class AdminAutomatorSkillsRequest(google.protobuf.message.Message):
    """*
    Retrieve the list of known skills that Automators can have.
    This is NOT the list of skills that a particular Automator has.

    Returns AdminAutomatorSkillsResponse.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    AUTOMATORID_FIELD_NUMBER: builtins.int
    automatorId: builtins.int
    """Not currently used but may be used in the future to filter the returned list."""
    def __init__(
        self,
        *,
        automatorId: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["automatorId", b"automatorId"]) -> None: ...

global___AdminAutomatorSkillsRequest = AdminAutomatorSkillsRequest

@typing.final
class AutomatorSkill(google.protobuf.message.Message):
    """*
    Information about a specific defined skill such as Device Approval.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SKILLTYPE_FIELD_NUMBER: builtins.int
    NAME_FIELD_NUMBER: builtins.int
    TRANSLATEDNAME_FIELD_NUMBER: builtins.int
    skillType: global___SkillType.ValueType
    """The actual skill type"""
    name: builtins.str
    """An internal ID tag, to be translated"""
    translatedName: builtins.str
    """The skill name translated into the destination language"""
    def __init__(
        self,
        *,
        skillType: global___SkillType.ValueType = ...,
        name: builtins.str = ...,
        translatedName: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["name", b"name", "skillType", b"skillType", "translatedName", b"translatedName"]) -> None: ...

global___AutomatorSkill = AutomatorSkill

@typing.final
class AdminAutomatorSkillsResponse(google.protobuf.message.Message):
    """*
    Contains a list of known skill types that Automators can have.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SUCCESS_FIELD_NUMBER: builtins.int
    MESSAGE_FIELD_NUMBER: builtins.int
    AUTOMATORSKILLS_FIELD_NUMBER: builtins.int
    success: builtins.bool
    """Was the call successful?"""
    message: builtins.str
    """If non-empty, should be displayed to the user"""
    @property
    def automatorSkills(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___AutomatorSkill]: ...
    def __init__(
        self,
        *,
        success: builtins.bool = ...,
        message: builtins.str = ...,
        automatorSkills: collections.abc.Iterable[global___AutomatorSkill] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["automatorSkills", b"automatorSkills", "message", b"message", "success", b"success"]) -> None: ...

global___AdminAutomatorSkillsResponse = AdminAutomatorSkillsResponse

@typing.final
class AdminResetAutomatorRequest(google.protobuf.message.Message):
    """*
    Sends a message to an Automator to reset all of its settings so that it can be re-initialized.

    We don't want this in the Console - just in Commander, or for use in testing.

    Returns AdminResponse
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    AUTOMATORID_FIELD_NUMBER: builtins.int
    automatorId: builtins.int
    def __init__(
        self,
        *,
        automatorId: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["automatorId", b"automatorId"]) -> None: ...

global___AdminResetAutomatorRequest = AdminResetAutomatorRequest

@typing.final
class AdminInitializeAutomatorRequest(google.protobuf.message.Message):
    """*
    Sends configuration settings to an Automator.
    Call this after AdminAutomatorEdit to send the new settings to the Automator.

    Returns AdminResponse
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    AUTOMATORID_FIELD_NUMBER: builtins.int
    automatorId: builtins.int
    def __init__(
        self,
        *,
        automatorId: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["automatorId", b"automatorId"]) -> None: ...

global___AdminInitializeAutomatorRequest = AdminInitializeAutomatorRequest

@typing.final
class AdminAutomatorLogRequest(google.protobuf.message.Message):
    """*
    AdminAutomatorLogRequest

    Retrieves the internal log entries of Keeper that relate to the given Automator instance.
    It does not contact the remote Automator.

    Returns AdminResponse
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    AUTOMATORID_FIELD_NUMBER: builtins.int
    automatorId: builtins.int
    def __init__(
        self,
        *,
        automatorId: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["automatorId", b"automatorId"]) -> None: ...

global___AdminAutomatorLogRequest = AdminAutomatorLogRequest

@typing.final
class AdminAutomatorLogClearRequest(google.protobuf.message.Message):
    """*
    AdminAutomatorLogClearRequest

    Clears the internal log entries of Keeper that relate to the given Automator instance.
    It does not contact the remote Automator.

    Returns AdminResponse
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    AUTOMATORID_FIELD_NUMBER: builtins.int
    automatorId: builtins.int
    def __init__(
        self,
        *,
        automatorId: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["automatorId", b"automatorId"]) -> None: ...

global___AdminAutomatorLogClearRequest = AdminAutomatorLogClearRequest

@typing.final
class ApproveTeamsForUserRequest(google.protobuf.message.Message):
    """----------------- Below are messages related to Team Approval and Team for User Approval

    *
    ApproveTeamsForUserRequest

    A message from Keeper to Automator asking for approval to add a user to one or more teams.

    @return an AutomatorResponse containing an ApproveTeamsForUserResponse
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    AUTOMATORID_FIELD_NUMBER: builtins.int
    SSOAUTHENTICATIONPROTOCOLTYPE_FIELD_NUMBER: builtins.int
    AUTHMESSAGE_FIELD_NUMBER: builtins.int
    EMAIL_FIELD_NUMBER: builtins.int
    SERVERECCPUBLICKEYID_FIELD_NUMBER: builtins.int
    IPADDRESS_FIELD_NUMBER: builtins.int
    USERPUBLICKEY_FIELD_NUMBER: builtins.int
    TEAMDESCRIPTION_FIELD_NUMBER: builtins.int
    ISTESTING_FIELD_NUMBER: builtins.int
    ISECCONLY_FIELD_NUMBER: builtins.int
    USERPUBLICKEYECC_FIELD_NUMBER: builtins.int
    automatorId: builtins.int
    """The ID of the automator instance being contacted."""
    ssoAuthenticationProtocolType: global___SsoAuthenticationProtocolType.ValueType
    """SAML2 or other"""
    authMessage: builtins.str
    """The SAML (or other) authentication message sent from the IdP to Keeper"""
    email: builtins.str
    """Email address of the user being authenticated"""
    serverEccPublicKeyId: builtins.int
    """This is included in every request"""
    ipAddress: builtins.str
    """The ip address of the user requesting approval"""
    userPublicKey: builtins.bytes
    """RSA public key used to encrypt the team key upon approval"""
    isTesting: builtins.bool
    """True if this call is part of a unit test"""
    isEccOnly: builtins.bool
    """If true, do not send any RSA-encrypted results"""
    userPublicKeyEcc: builtins.bytes
    """ECC public key Used to encrypt the team key upon approval"""
    @property
    def teamDescription(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___TeamDescription]:
        """One or more teams to add the user to"""

    def __init__(
        self,
        *,
        automatorId: builtins.int = ...,
        ssoAuthenticationProtocolType: global___SsoAuthenticationProtocolType.ValueType = ...,
        authMessage: builtins.str = ...,
        email: builtins.str = ...,
        serverEccPublicKeyId: builtins.int = ...,
        ipAddress: builtins.str = ...,
        userPublicKey: builtins.bytes = ...,
        teamDescription: collections.abc.Iterable[global___TeamDescription] | None = ...,
        isTesting: builtins.bool = ...,
        isEccOnly: builtins.bool = ...,
        userPublicKeyEcc: builtins.bytes = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["authMessage", b"authMessage", "automatorId", b"automatorId", "email", b"email", "ipAddress", b"ipAddress", "isEccOnly", b"isEccOnly", "isTesting", b"isTesting", "serverEccPublicKeyId", b"serverEccPublicKeyId", "ssoAuthenticationProtocolType", b"ssoAuthenticationProtocolType", "teamDescription", b"teamDescription", "userPublicKey", b"userPublicKey", "userPublicKeyEcc", b"userPublicKeyEcc"]) -> None: ...

global___ApproveTeamsForUserRequest = ApproveTeamsForUserRequest

@typing.final
class TeamDescription(google.protobuf.message.Message):
    """*
    TeamDescription

    Description of a team involved in a Team approval or Team for User approval.
    Used in ApproveTeamsForUserRequest.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TEAMUID_FIELD_NUMBER: builtins.int
    TEAMNAME_FIELD_NUMBER: builtins.int
    ENCRYPTEDTEAMKEY_FIELD_NUMBER: builtins.int
    ENCRYPTEDTEAMKEYTYPE_FIELD_NUMBER: builtins.int
    teamUid: builtins.bytes
    """The team UID the user is being added to"""
    teamName: builtins.str
    """The name of the team the user is being added to"""
    encryptedTeamKey: builtins.bytes
    """The encrypted team key.  It is encrypted by the user's public key or the enterprise tree key"""
    encryptedTeamKeyType: enterprise_pb2.EncryptedKeyType.ValueType
    """The type of the encrypted team key"""
    def __init__(
        self,
        *,
        teamUid: builtins.bytes = ...,
        teamName: builtins.str = ...,
        encryptedTeamKey: builtins.bytes = ...,
        encryptedTeamKeyType: enterprise_pb2.EncryptedKeyType.ValueType = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["encryptedTeamKey", b"encryptedTeamKey", "encryptedTeamKeyType", b"encryptedTeamKeyType", "teamName", b"teamName", "teamUid", b"teamUid"]) -> None: ...

global___TeamDescription = TeamDescription

@typing.final
class ApproveTeamsForUserResponse(google.protobuf.message.Message):
    """*
    ApproveTeamsForUserResponse

    The Response from Automator when a team is or is not approved.
    It is included in an AutomatorResponse.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    AUTOMATORID_FIELD_NUMBER: builtins.int
    EMAIL_FIELD_NUMBER: builtins.int
    MESSAGE_FIELD_NUMBER: builtins.int
    APPROVETEAMRESPONSE_FIELD_NUMBER: builtins.int
    automatorId: builtins.int
    """The automator responding"""
    email: builtins.str
    """The username of the user being approved"""
    message: builtins.str
    """If a general error occurred, this will contain an error message and approveTeamResponse will be empty"""
    @property
    def approveTeamResponse(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ApproveOneTeamForUserResponse]:
        """One approval decision for each team listed in the ApproveTeamsForUserRequest"""

    def __init__(
        self,
        *,
        automatorId: builtins.int = ...,
        email: builtins.str = ...,
        message: builtins.str = ...,
        approveTeamResponse: collections.abc.Iterable[global___ApproveOneTeamForUserResponse] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["approveTeamResponse", b"approveTeamResponse", "automatorId", b"automatorId", "email", b"email", "message", b"message"]) -> None: ...

global___ApproveTeamsForUserResponse = ApproveTeamsForUserResponse

@typing.final
class ApproveOneTeamForUserResponse(google.protobuf.message.Message):
    """*
    ApproveOneTeamForUserResponse

    Part of the ApproveTeamsForUserResponse.
    Provides information needed to add one user to one team.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    APPROVED_FIELD_NUMBER: builtins.int
    MESSAGE_FIELD_NUMBER: builtins.int
    TEAMUID_FIELD_NUMBER: builtins.int
    TEAMNAME_FIELD_NUMBER: builtins.int
    USERENCRYPTEDTEAMKEY_FIELD_NUMBER: builtins.int
    USERENCRYPTEDTEAMKEYTYPE_FIELD_NUMBER: builtins.int
    USERENCRYPTEDTEAMKEYBYECC_FIELD_NUMBER: builtins.int
    USERENCRYPTEDTEAMKEYBYECCTYPE_FIELD_NUMBER: builtins.int
    approved: builtins.bool
    """True if the user is approved for the team"""
    message: builtins.str
    """If the team was not approved, this field will contain a message explaining why"""
    teamUid: builtins.bytes
    """The team involved in this request/response"""
    teamName: builtins.str
    """The team name"""
    userEncryptedTeamKey: builtins.bytes
    """The team key encrypted with the user's public RSA key, if it was approved.  Empty if not approved"""
    userEncryptedTeamKeyType: enterprise_pb2.EncryptedKeyType.ValueType
    """Will normally be 2, corresponding to ENCRYPTED_BY_PUBLIC_KEY.  Empty if not approved"""
    userEncryptedTeamKeyByEcc: builtins.bytes
    """The team key encrypted with the user's public ECC key"""
    userEncryptedTeamKeyByEccType: enterprise_pb2.EncryptedKeyType.ValueType
    """Will normally be 4, corresponding to ENCRYPTED_BY_PUBLIC_KEY_ECC"""
    def __init__(
        self,
        *,
        approved: builtins.bool = ...,
        message: builtins.str = ...,
        teamUid: builtins.bytes = ...,
        teamName: builtins.str = ...,
        userEncryptedTeamKey: builtins.bytes = ...,
        userEncryptedTeamKeyType: enterprise_pb2.EncryptedKeyType.ValueType = ...,
        userEncryptedTeamKeyByEcc: builtins.bytes = ...,
        userEncryptedTeamKeyByEccType: enterprise_pb2.EncryptedKeyType.ValueType = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["approved", b"approved", "message", b"message", "teamName", b"teamName", "teamUid", b"teamUid", "userEncryptedTeamKey", b"userEncryptedTeamKey", "userEncryptedTeamKeyByEcc", b"userEncryptedTeamKeyByEcc", "userEncryptedTeamKeyByEccType", b"userEncryptedTeamKeyByEccType", "userEncryptedTeamKeyType", b"userEncryptedTeamKeyType"]) -> None: ...

global___ApproveOneTeamForUserResponse = ApproveOneTeamForUserResponse

@typing.final
class ApproveTeamsRequest(google.protobuf.message.Message):
    """-----------------------------------------------------------------

    *
    ApproveTeamsRequest

    A message from Keeper to Automator asking for approval to create one or more teams.

    @return an AutomatorResponse containing an ApproveTeamsResponse
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    AUTOMATORID_FIELD_NUMBER: builtins.int
    SSOAUTHENTICATIONPROTOCOLTYPE_FIELD_NUMBER: builtins.int
    AUTHMESSAGE_FIELD_NUMBER: builtins.int
    EMAIL_FIELD_NUMBER: builtins.int
    SERVERECCPUBLICKEYID_FIELD_NUMBER: builtins.int
    IPADDRESS_FIELD_NUMBER: builtins.int
    TEAMDESCRIPTION_FIELD_NUMBER: builtins.int
    ISECCONLY_FIELD_NUMBER: builtins.int
    ISTESTING_FIELD_NUMBER: builtins.int
    automatorId: builtins.int
    """The ID of the automator instance being contacted."""
    ssoAuthenticationProtocolType: global___SsoAuthenticationProtocolType.ValueType
    """SAML2 or other"""
    authMessage: builtins.str
    """The SAML (or other) authentication message sent from the IdP to Keeper"""
    email: builtins.str
    """Email address of the user being authenticated"""
    serverEccPublicKeyId: builtins.int
    """This is included in every request"""
    ipAddress: builtins.str
    """The ip address of the user requesting approval"""
    isEccOnly: builtins.bool
    """If true, do not send any RSA-encrypted results"""
    isTesting: builtins.bool
    """True if this call is part of a unit test"""
    @property
    def teamDescription(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___TeamDescription]:
        """One or more teams to approve/create.  The encrypted key field is ignored"""

    def __init__(
        self,
        *,
        automatorId: builtins.int = ...,
        ssoAuthenticationProtocolType: global___SsoAuthenticationProtocolType.ValueType = ...,
        authMessage: builtins.str = ...,
        email: builtins.str = ...,
        serverEccPublicKeyId: builtins.int = ...,
        ipAddress: builtins.str = ...,
        teamDescription: collections.abc.Iterable[global___TeamDescription] | None = ...,
        isEccOnly: builtins.bool = ...,
        isTesting: builtins.bool = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["authMessage", b"authMessage", "automatorId", b"automatorId", "email", b"email", "ipAddress", b"ipAddress", "isEccOnly", b"isEccOnly", "isTesting", b"isTesting", "serverEccPublicKeyId", b"serverEccPublicKeyId", "ssoAuthenticationProtocolType", b"ssoAuthenticationProtocolType", "teamDescription", b"teamDescription"]) -> None: ...

global___ApproveTeamsRequest = ApproveTeamsRequest

@typing.final
class ApproveTeamsResponse(google.protobuf.message.Message):
    """*
    ApproveTeamsResponse

    The Response from Automator when a team is or is not approved.
    It is included in an AutomatorResponse.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    AUTOMATORID_FIELD_NUMBER: builtins.int
    MESSAGE_FIELD_NUMBER: builtins.int
    APPROVETEAMRESPONSE_FIELD_NUMBER: builtins.int
    automatorId: builtins.int
    """The automator responding"""
    message: builtins.str
    """If a general error occurred, this will contain an error message and approveTeamResponse will be empty"""
    @property
    def approveTeamResponse(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ApproveOneTeamResponse]:
        """One approval decision for each team listed in the ApproveTeamsRequest"""

    def __init__(
        self,
        *,
        automatorId: builtins.int = ...,
        message: builtins.str = ...,
        approveTeamResponse: collections.abc.Iterable[global___ApproveOneTeamResponse] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["approveTeamResponse", b"approveTeamResponse", "automatorId", b"automatorId", "message", b"message"]) -> None: ...

global___ApproveTeamsResponse = ApproveTeamsResponse

@typing.final
class ApproveOneTeamResponse(google.protobuf.message.Message):
    """*
    ApproveOneTeamResponse

    The Response from Automator when a team is or is not approved.
    It is included in an ApproveTeamsResponse.
    Fields 5 and above will be empty if the team was not approved.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    APPROVED_FIELD_NUMBER: builtins.int
    MESSAGE_FIELD_NUMBER: builtins.int
    TEAMUID_FIELD_NUMBER: builtins.int
    TEAMNAME_FIELD_NUMBER: builtins.int
    ENCRYPTEDTEAMKEYCBC_FIELD_NUMBER: builtins.int
    ENCRYPTEDTEAMKEYCBCTYPE_FIELD_NUMBER: builtins.int
    ENCRYPTEDTEAMKEYGCM_FIELD_NUMBER: builtins.int
    ENCRYPTEDTEAMKEYGCMTYPE_FIELD_NUMBER: builtins.int
    TEAMPUBLICKEYRSA_FIELD_NUMBER: builtins.int
    ENCRYPTEDTEAMPRIVATEKEYRSA_FIELD_NUMBER: builtins.int
    ENCRYPTEDTEAMPRIVATEKEYRSATYPE_FIELD_NUMBER: builtins.int
    TEAMPUBLICKEYECC_FIELD_NUMBER: builtins.int
    ENCRYPTEDTEAMPRIVATEKEYECC_FIELD_NUMBER: builtins.int
    ENCRYPTEDTEAMPRIVATEKEYECCTYPE_FIELD_NUMBER: builtins.int
    approved: builtins.bool
    """True if the team was approved"""
    message: builtins.str
    """If the team was not approved, this field will contain a message explaining why"""
    teamUid: builtins.bytes
    """The team involved in this request/response"""
    teamName: builtins.str
    """The team name"""
    encryptedTeamKeyCbc: builtins.bytes
    """The team key encrypted with the user's data key using AES/CBC.  Base64 url-encoded. THIS WILL BE EMPTY FOR NOW."""
    encryptedTeamKeyCbcType: enterprise_pb2.EncryptedKeyType.ValueType
    """Will normally be 1, ENCRYPTED_BY_DATA_KEY_CBC. Base64 url-encoded."""
    encryptedTeamKeyGcm: builtins.bytes
    """The team key encrypted with the tree key using AES/GCM.  Base64 url-encoded."""
    encryptedTeamKeyGcmType: enterprise_pb2.EncryptedKeyType.ValueType
    """Will normally be 3, ENCRYPTED_BY_DATA_KEY_GCM. Base64 url-encoded."""
    teamPublicKeyRsa: builtins.bytes
    """Generated team RSA public key, Base64 url-encoded.  May be empty"""
    encryptedTeamPrivateKeyRsa: builtins.bytes
    """Generated RSA private key encrypted with the team key using AES/CBC. Base64 url-encoded."""
    encryptedTeamPrivateKeyRsaType: enterprise_pb2.EncryptedKeyType.ValueType
    """Will normally be 1, ENCRYPTED_BY_DATA_KEY_CBC."""
    teamPublicKeyEcc: builtins.bytes
    """Generated team ECC public key. Base64 url-encoded."""
    encryptedTeamPrivateKeyEcc: builtins.bytes
    """Generated team ECC private key encrypted with the team key using AES/GCM.  Base64 url-encoded."""
    encryptedTeamPrivateKeyEccType: enterprise_pb2.EncryptedKeyType.ValueType
    """Will normally be 3, ENCRYPTED_BY_DATA_KEY_GCM. Base64 url-encoded."""
    def __init__(
        self,
        *,
        approved: builtins.bool = ...,
        message: builtins.str = ...,
        teamUid: builtins.bytes = ...,
        teamName: builtins.str = ...,
        encryptedTeamKeyCbc: builtins.bytes = ...,
        encryptedTeamKeyCbcType: enterprise_pb2.EncryptedKeyType.ValueType = ...,
        encryptedTeamKeyGcm: builtins.bytes = ...,
        encryptedTeamKeyGcmType: enterprise_pb2.EncryptedKeyType.ValueType = ...,
        teamPublicKeyRsa: builtins.bytes = ...,
        encryptedTeamPrivateKeyRsa: builtins.bytes = ...,
        encryptedTeamPrivateKeyRsaType: enterprise_pb2.EncryptedKeyType.ValueType = ...,
        teamPublicKeyEcc: builtins.bytes = ...,
        encryptedTeamPrivateKeyEcc: builtins.bytes = ...,
        encryptedTeamPrivateKeyEccType: enterprise_pb2.EncryptedKeyType.ValueType = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["approved", b"approved", "encryptedTeamKeyCbc", b"encryptedTeamKeyCbc", "encryptedTeamKeyCbcType", b"encryptedTeamKeyCbcType", "encryptedTeamKeyGcm", b"encryptedTeamKeyGcm", "encryptedTeamKeyGcmType", b"encryptedTeamKeyGcmType", "encryptedTeamPrivateKeyEcc", b"encryptedTeamPrivateKeyEcc", "encryptedTeamPrivateKeyEccType", b"encryptedTeamPrivateKeyEccType", "encryptedTeamPrivateKeyRsa", b"encryptedTeamPrivateKeyRsa", "encryptedTeamPrivateKeyRsaType", b"encryptedTeamPrivateKeyRsaType", "message", b"message", "teamName", b"teamName", "teamPublicKeyEcc", b"teamPublicKeyEcc", "teamPublicKeyRsa", b"teamPublicKeyRsa", "teamUid", b"teamUid"]) -> None: ...

global___ApproveOneTeamResponse = ApproveOneTeamResponse
