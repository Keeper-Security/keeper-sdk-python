import enum
from concurrent.futures import Future
from typing import Optional, Dict, Sequence, TypeVar, Type, Callable, Union, List, Any

from cryptography.hazmat.primitives.asymmetric.ec import EllipticCurvePrivateKey, EllipticCurvePublicKey
from cryptography.hazmat.primitives.asymmetric.rsa import RSAPrivateKey, RSAPublicKey
from google.protobuf.message import Message

from . import endpoint, notifications


class SessionTokenRestriction(enum.IntFlag):
    Unrestricted = ...
    AccountRecovery = ...
    ShareAccount = ...
    AcceptInvite = ...
    AccountExpired = ...


class AccountAuthType(enum.Enum):
    Regular = ...
    CloudSso = ...
    OnsiteSso = ...
    ManagedCompany = ...


class AuthContext:
    username: str
    session_token: bytes
    session_token_restriction: SessionTokenRestriction

    data_key: bytes
    client_key: bytes
    rsa_private_key: Optional[RSAPrivateKey]
    ec_private_key: Optional[EllipticCurvePrivateKey]
    enterprise_ec_public_key: Optional[EllipticCurvePublicKey]
    enterprise_rsa_public_key: Optional[RSAPublicKey]
    is_enterprise_admin: bool

    enforcements: Dict[str, any]
    settings: Dict[str, any]
    license: Dict[str, any]

TRQ = TypeVar('TRQ', bound=Message)
TRS = TypeVar('TRS', bound=Message)

class KeeperAuth(...):
    def __init__(self, keeper_endpoint: endpoint.KeeperEndpoint, auth_context: AuthContext) -> None: ...
    push_notifications: Optional[notifications.FanOut[Dict[str, Any]]]
    keeper_endpoint: endpoint.KeeperEndpoint
    auth_context: AuthContext

    def execute_auth_rest(self, rest_endpoint: str, request: Optional[TRQ],
                          response_type: Optional[Type[TRS]] = None) -> Optional[TRS]: ...
    def execute_auth_command(self, request: Dict[str, any], throw_on_error: bool = True) -> Dict[str, any]: ...
    def execute_async(self, fn: Callable, *args, **kwargs) -> Future:
    def execute_batch(self, requests: List[Dict[str, any]], throw_on_error: bool = True) -> List[Dict[str, any]]: ...

    def close(self) -> None: ...

class ILoginStep:
    def close(self) -> None: ...
    def is_final(self) -> bool: ...

class LoginAuth(...):
    def __init__(self, keeper_endpoint: endpoint.KeeperEndpoint) -> None: ...

    keeper_endpoint: endpoint.KeeperEndpoint
    push_notifications: Optional[notifications.FanOut[Dict[str, any]]]
    login_step: Union[LoginStepReady, LoginStepDeviceApproval, LoginStepTwoFactor, LoginStepPassword, LoginStepConnected]
    alternate_password: bool
    resume_session: bool
    on_next_step: Optional[Callable[[], None]]
    on_region_changed: Optional[Callable[[str], None]]

    def execute_rest(self, rest_endpoint: str, request: Optional[TRQ],
                     response_type: Optional[Type[TRS]] = None) -> Optional[TRS]: ...

    def login(self, username: str, *passwords: str) -> None: ...
    # def login_sso(self, provider_name: str) -> None: ...

class LoginStepReady(ILoginStep):
    ...

class DeviceApprovalChannel(enum.Enum):
    Email = ...
    KeeperPush = ...
    TwoFactor = ...

class LoginStepDeviceApproval(ILoginStep):
    def send_push(self, channel: DeviceApprovalChannel) -> None: ...
    def send_code(self, channel: DeviceApprovalChannel, code: str) -> None: ...
    def resume(self): ...


class TwoFactorChannel(enum.Enum):
    Other = ...
    Authenticator = ...
    TextMessage = ...
    DuoSecurity = ...
    RSASecurID = ...
    KeeperDNA = ...
    SecurityKey = ...
    Backup = ...

class TwoFactorPushAction(enum.Enum):
    DuoPush = ...
    DuoTextMessage = ...
    DuoVoiceCall = ...
    TextMessage = ...
    KeeperDna = ...

class TwoFactorDuration(enum.Enum):
    EveryLogin = ...
    EveryDay = ...
    Every30Days = ...
    Forever = ...

class TwoFactorChannelInfo:
    channel_type: TwoFactorChannel
    channel_name: str
    channel_uid: bytes
    phone: Optional[str]
    max_expiration: TwoFactorDuration

class LoginStepTwoFactor(ILoginStep):
    duration: TwoFactorDuration

    def get_channels(self) -> Sequence[TwoFactorChannelInfo]: ...
    def get_channel_push_actions(self, channel_uid: bytes) -> Sequence[TwoFactorPushAction]: ...

    def send_push(self, channel_uid: bytes, action: TwoFactorPushAction) -> None: ...
    def send_code(self, channel_uid: bytes, code: str) -> None: ...
    def resume(self): ...


class LoginStepPassword(ILoginStep):
    def verify_password(self, password: str) -> None: ...
    def verify_biometric_key(self, biometric_key: bytes) -> None: ...

class LoginStepSsoToken(ILoginStep):
    def set_sso_token(self, token: str) -> None: ...
    def login_with_password(self) -> None: ...
    @property
    def is_cloud_sso(self) -> bool: ...
    @property
    def is_provider_login(self) -> bool: ...
    @property
    def login_name(self) -> str: ...
    @property
    def sso_login_url(self) -> str: ...

class LoginStepConnected(ILoginStep):
    def keeper_auth(self) -> KeeperAuth: ...

class DataKeyShareChannel(enum.Enum):
    KeeperPush = ...
    AdminApproval = ...

class LoginStepSsoDataKey(ILoginStep):
    def get_channels(self) -> Sequence[DataKeyShareChannel]: ...
    def request_data_key(self, channel: DataKeyShareChannel) -> None: ...

class LoginStepError(ILoginStep):
    def __init__(self, code: str, message: str) -> None: ...
    code: str
    message: str

class SsoLoginInfo:
    is_cloud: bool
    sso_provider: str
    sso_url: str
    idp_session_id: str
